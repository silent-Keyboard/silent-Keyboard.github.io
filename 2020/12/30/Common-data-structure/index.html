<html>
<head>
	
	<title>线性表</title>
	<meta name="keywords" content="zwhfocus.github.io" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        
<script src="/js/util.js"></script>

        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/%EF%BD%9A.ico?v=3"/>
    
    

<meta name="generator" content="Hexo 5.3.0"></head>

<body>


<h2 class="title">线性表</h2>
<div style="text-align:center;margin-top: -10px;">
    <div class="article-category">
    发表于2020年12月30日
    
    
    
    
     </div>
</div>

<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%8E%E6%95%88%E7%8E%87%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">数组的低效率插入删除操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li></ol></li></ol>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ul>
<li>线性表的逻辑结构：数据元素之间存在一对一的前驱后继关系</li>
<li>线性表的物理结构：顺序存储结构、链式存储结构</li>
<li>数据的运算：对元素进行某种操作，比如判读线性表是否为空，确定线性表长度，查找某个元素，删除某个元素以及在指定位置插入某个元素<br><img src="LinerTable.png" alt="线性表"><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>什么是数组？数组是一种用连续的存储空间来存储相同数据类型的存储结构。理解连续的存储空间可以类比一层一层的楼梯，每个台阶都存储一个数据，连续的台阶就可以当作一个数组。</p>
</blockquote>
</li>
</ul>
<p>大多数编程语言都会有数组的概念，并且大多数编程语言的数组的下标是从0开始的，理解数组的下标为什么以0开始时需要一些计算机基础的知识。</p>
<p>首先需要理解数组的在计算机中的内存地址，连续存储空间以及相同数据类型<br><img src="array.png" alt="数组"><br>以下公式是计算数组第K个位置的元素的地址，base_address是数组首个元素地址，type_size是数组中元素的数据类型大小。如果数组下标从1开始则第K个元素的地址计算操作就比数组下标是0多个减法的操作。这在最初的C语言中是会影响性能的，尤其是在数组这个数据结构经常使用的情况下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + k * type_size</span><br></pre></td></tr></table></figure>
<p>此外根据上面的公式也是可以得出一个结论的：数组支持随机访问，并且根据下标进行随机访问的时间复杂度是O(1)。那什么叫做随机访问，简单来说就是我有一个数组，然后你随便给我一个数字，只要数组存在这个下标的元素， 我都可以立即找到该元素并且花费的时间是O(1)。</p>
<h4 id="数组的低效率插入删除操作"><a href="#数组的低效率插入删除操作" class="headerlink" title="数组的低效率插入删除操作"></a>数组的低效率插入删除操作</h4><p>首先看看数组的插入操作，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void addElement(int[] arr, int element, int position)&#123;</span><br><span class="line">    int len &#x3D; arr.length();</span><br><span class="line">    for(int i &#x3D; len; i &gt;position; i--)&#123;</span><br><span class="line">        arr[i] &#x3D; arr[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[position] &#x3D; element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码只是简单的描述了数组的插入操作大致的逻辑，把一个元素插入到数组中主要有三种情况。第一种是插入到数组末尾，这时不需要什么额外的操作，直接arr[position] = element即可；第二种情况是插入到数组头部，这时候需要将所有的元素往后移动，这时候的时间复杂度和数组规模有关，假设数组规模大小n,这时候的时间复杂度是O(n)；第三种情况是插入到数组中间某个位置position,这时候需要将postition之后的元素都往后移一位，时间复杂度是O(n-postition)，也可以理解为是关于n的线性关系。从数学的角度分析，插入到数组每个位置的概率几乎一样，第一个位置需要移动n个元素，第二个位置需要移动n-1位，以此类推，最后一个位置不需要移动元素，平均下来，每个位置需要移动的元素（0+1+2+…n）/(n+1),仍然是关于n的线性关系。综上述数组的插入操作的平均时间复杂度是O(n)。</p>
<p>关于数组的删除操作其实也是类似的，删除操作的平均时间复杂度是O(n).<br>简单应用：关于数组的删除操作，如果删除操作太过于频繁，这时候为了减少该重复的操作，一般都会采用标记删除的方法。即把要删除的元素做一个标记，待到一定时机一次性删除本来应该删除的元素。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><blockquote>
<p>关于链表，首先需要理解链表是怎样的一个数据结构，其次链表的基本操作的图解，最后就是编写链表代码。</p>
</blockquote>
<p>以单链表为例，单链表的结构就像排队一样，队列中的每个人只知道在自己以及自己前面的一个人是谁，而不知道自己后面的一个人是谁。这些都好理解，唯一有难度的就是如何编写链表的代码。</p>
<p>第一个概念指针或引用:C语言中有指针而Java中有引用，但两者其实是同一个东西。指针或引用都是一个存储着内存地址的变量，类似于一个装有收件人信息的包裹。知道指针的概念之后，你可以使用指针去指向链表中的任意一个结点进行操作。参照排队，正在排队的每个人都可以是一个结点，而我之所以知道我前面的一个人，是因为我本身知道我前面的一个人的内存地址，通过内存地址可以直接找到他。或者可以更形象的说，只有我们每个人都记住自己前面的一个人的内存地址才能构成一个链表，否则有可能在中途断链。但是如果有人中途插队或者离队的话，那怎么操作呢，这时候就需要借助指针或引用的概念。</p>
<p>有人中途插队：假设有x想插队，x想插到y后面，已知y后面是z。我们要知道x没插队之前，z存储的前一个人的内存地址是y，现在呢x要插队，插队时是必须要保证链表不能断的,所以z存储的前一个人的内存地址应该是x,并且x存储的前一个人的内存地址应该是y，另外别忘了，x插队之前必须先记住自己前面的一个人的内存地址然后让自己后面的一个人记住自己的内存地址。</p>

<!--
<a href="http://example.com/2020/12/30/Common-data-structure/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>